"""
Setup for a "base experiment".

To allow us to be flexible with the type of ARTIQ we run in the future,
we do not inherit from an artiq experiment, but add variables and devices
as attributes to an experiment passed by reference to the functions below.

There are also some quality of life functions here.

intended usage:
----
from BaseExperiment import BaseExperiment


class MyExp(EnvExperiment):

    def build:
        # gets variables and devices
        self.base = BaseExperiment(experiment=self)
        self.base.build()

        # define GUI arguments here
        self.setattr_argument("my_argument",NumberValue(5))

        self.base.set_datasets_from_gui_args()

    def prepare:
        self.base.prepare()

    @kernel
    def run:
        self.base.initialize_hardware()
        # now we can do physics

        # reference devices and variables which were initialized in the base experiment
        self.dds_AOM_A1.sw.on()
        self.ttl6.pulse(self.t_pulse)
----
"""
from artiq.experiment import *
import logging
import numpy as np
from numpy import inf
import sys, os
import json

cwd = os.getcwd() + "\\"
sys.path.append(cwd)
sys.path.append(cwd+"\\repository\\qn_artiq_routines")

from subroutines.aom_feedback import AOMPowerStabilizer
from ExperimentVariables import setattr_variables
from utilities.DeviceAliases import DeviceAliases
from utilities.write_h5 import write_results
from utilities.conversions import dB_to_V
from K10CR1.KinesisMotorWrapper import KinesisMotorWrapper

import os

cwd = os.getcwd() # must be called here. if called in class, returns the results level dir


class BaseExperiment:

    def __init__(self, experiment: EnvExperiment):
        """
        Instantiate BaseExperiment in your build method, with experiment=self
        :param experiment: an instance of an ARTIQ Experiment.
        """
        self.node = experiment.get_dataset("which_node")
        self.experiment = experiment

        devices_file = os.path.join(cwd, "repository\\qn_artiq_routines\\utilities\\config\\",
                                    self.node,
                                    "device_aliases.json")

        with open(devices_file) as f:
            devices_dict = json.load(f)
            self.experiment.alias_map = devices_dict["ALIAS_MAP"]
            self.experiment.dds_defaults = devices_dict["DDS_DEFAULTS"]

    def build(self):
        """
        Put this in your experiment's build method

        Assigning attributes and methods to the experiment should be done here.

        The main difference between Base.build and Base.prepare is that build should contain things we only
        want to happen once per experiment, whereas we might want to call prepare each iteration to reinitialize
        things pertaining to hardware.

        :param experiment: your experiment.
        :return:
        """

        with open(os.path.join(cwd,'dataset_db.pyon')) as f:
            datasets_str = f.read()

        # when the pyon file is saved python True and False are converted to lowercase...
        datasets_str = datasets_str.replace("true", "True")
        datasets_str = datasets_str.replace("false", "False")
        datasets_dict = eval(datasets_str)

        # these are the names of all of the datasets, which we're going to use to create attributes of the same name
        self.experiment.variables = datasets_dict.keys()

        # we don't want to try to add long lists as experiment attributes. this can result in timeout exceptions.
        exclude_keywords = ['history']# for autogenerated datasets so we don't have to remember to add variables later
        setattr_variables(self.experiment, exclude_list=[], exclude_keywords=exclude_keywords)

        self.experiment.SPCM0_RO1 = 0
        self.experiment.SPCM0_RO2 = 0
        self.experiment.SPCM1_RO1 = 0
        self.experiment.SPCM1_RO2 = 0

        self.experiment.SPCM0_FORT_science = 0
        self.experiment.measurement = 0
        self.experiment.ro_dma_handle = (np.int32(0), np.int64(0), np.int32(0))
        self.experiment.ro_dma_handle2 = (np.int32(0), np.int64(0), np.int32(0))

        if self.node == "alice":
            # devices without nicknames. core should come first
            devices_no_alias = ["core",
                                "core_dma",
                                "scheduler",
                                "urukul0_cpld", "urukul1_cpld", "urukul2_cpld",
                                "zotino0",  # for controlling coils
                                "sampler0",  # for measuring laser power PD
                                "sampler1", # for reading in volts in the coil tune experiment
                                "sampler2",
                                *[f"ttl{i}" for i in range(16)],
                                *[f"ttl{i}_counter" for i in range(4)],  # ttl card 0 edge counters
                                *[f"ttl{i}_counter" for i in range(8, 12)]]  # ttl card 1 edge counters

            for dev in devices_no_alias:
                self.experiment.setattr_device(dev)

            # devices can also be nicknamed here:
            # todo: do this in the device_db
            self.experiment.ttl_microwave_switch = self.experiment.ttl4
            self.experiment.ttl_repump_switch = self.experiment.ttl5
            self.experiment.ttl_SPCM0 = self.experiment.ttl0
            self.experiment.ttl_SPCM0_counter = self.experiment.ttl0_counter
            self.experiment.ttl_SPCM1 = self.experiment.ttl1
            self.experiment.ttl_SPCM1_counter = self.experiment.ttl1_counter
            self.experiment.ttl_scope_trigger = self.experiment.ttl7
            self.experiment.ttl_UV = self.experiment.ttl15
            self.experiment.ttl_SPCM_gate = self.experiment.ttl13
            self.experiment.ttl_D1_lock_monitor = self.experiment.ttl8
            self.experiment.FORT_mod_switch = self.experiment.ttl12
            # self.experiment.ttl_Luca_trigger = self.experiment.ttl6 # Luca no longer used.
            self.experiment.ttl_exc0_switch = self.experiment.ttl6
            # self.experiment.ttl_excitation_switch = self.experiment.ttl14
            self.experiment.ttl_GRIN1_switch = self.experiment.ttl14

            # for debugging/logging purposes in experiments
            self.experiment.coil_names = ["AZ bottom","AZ top","AX","AY"]

            self.experiment.AZ_bottom_Zotino_channel = 0
            self.experiment.AZ_top_Zotino_channel = 1
            self.experiment.AX_Zotino_channel = 2
            self.experiment.AY_Zotino_channel = 3

            self.experiment.coil_channels = [self.experiment.AZ_bottom_Zotino_channel,
                                             self.experiment.AZ_top_Zotino_channel,
                                             self.experiment.AX_Zotino_channel,
                                             self.experiment.AY_Zotino_channel]

            self.experiment.FORT_MM_sampler_ch = 7
            self.experiment.GRIN1_sampler_ch = 4  # Sampler1; function "measure_GRIN1" in experiment functions.py

            # for zotino stability test
            # self.zotino_test_1_Zotino_channel = 6  # Zotino 0 - ch6
            # self.zotino_test_2_Zotino_channel = 7  # Zotino 0 - ch7
            # self.experiment.zotino_test_channels = [self.zotino_test_1_Zotino_channel, self.zotino_test_2_Zotino_channel]


            # dataset names
            self.experiment.measurements_progress = 'measurements_progress'
            self.experiment.SPCM0_rate_dataset = 'SPCM0_counts_per_s'
            self.experiment.SPCM1_rate_dataset = 'SPCM1_counts_per_s'
            self.experiment.scan_var_dataset = "scan_variables"
            self.experiment.scan_sequence1_dataset = "scan_sequence1"
            self.experiment.scan_sequence2_dataset = "scan_sequence2"

            """
            Note that the amplitudes below can be used for setting the urukul channels, but are kernel invariants.
            If you are running the laser_stabilizer in your experiment, and you want to set one of the dds channels we
            feedback to (i.e. it is in one of the dds_feedback_lists in ExperimentVariables), then you should use the
            amplitude attribute of the feedback channel. See subroutines/aom_feedback.py for more details.
            """

            # converts RF power in dBm to amplitudes in V
            self.experiment.ampl_FORT_loading = dB_to_V(self.experiment.p_FORT_loading) # used only for old experiments
            self.experiment.ampl_cooling_DP_MOT = dB_to_V(self.experiment.p_cooling_DP_MOT)

            # RF powers defined as fractions of the defaults - warning: the AOM response isn't linear like this
            self.experiment.ampl_FORT_RO = self.experiment.ampl_FORT_loading * self.experiment.p_FORT_RO
            self.experiment.ampl_FORT_PGC = self.experiment.ampl_FORT_loading * self.experiment.p_FORT_PGC
            self.experiment.ampl_FORT_blowaway = self.experiment.ampl_FORT_loading * self.experiment.p_FORT_blowaway
            self.experiment.ampl_FORT_OP = self.experiment.ampl_FORT_loading * self.experiment.p_FORT_OP
            self.experiment.ampl_cooling_DP_RO = self.experiment.ampl_cooling_DP_MOT * self.experiment.p_cooling_DP_RO
            self.experiment.ampl_cooling_DP_PGC = self.experiment.ampl_cooling_DP_MOT * self.experiment.p_cooling_DP_PGC

        elif self.node == "bob":
            # devices without nicknames. core should come first
            devices_no_alias = ["core",
                                "core_dma",
                                "scheduler",
                                "urukul0_cpld", "urukul1_cpld", "urukul2_cpld",
                                "zotino0",  # for controlling coils
                                "sampler0",  # for measuring laser power PD
                                "sampler1", # for reading in volts in the coil tune experiment
                                "sampler2",
                                *[f"ttl{i}" for i in range(16)]] # todo: add edge_counters when gateware upgraded
            for dev in devices_no_alias:
                self.experiment.setattr_device(dev)

            # devices can also be nicknamed here:
            # todo: do this in the device_db
            self.experiment.ttl_microwave_switch = self.experiment.ttl4
            self.experiment.ttl_repump_switch = self.experiment.ttl5
            self.experiment.ttl_SPCM0 = self.experiment.ttl0
            self.experiment.ttl_SPCM0_counter = self.experiment.ttl0_counter
            self.experiment.ttl_scope_trigger = self.experiment.ttl7
            self.experiment.ttl_Luca_trigger = self.experiment.ttl6
            self.experiment.ttl_UV = self.experiment.ttl15
            self.experiment.ttl_SPCM_gate = self.experiment.ttl13

            # for debugging/logging purposes in experiments
            self.experiment.coil_names = ["AZ bottom","AZ top","AX","AY"]

            self.experiment.AZ_bottom_Zotino_channel = 0
            self.experiment.AZ_top_Zotino_channel = 1
            self.experiment.AX_Zotino_channel = 2
            self.experiment.AY_Zotino_channel = 3

            self.experiment.coil_channels = [self.experiment.AZ_bottom_Zotino_channel,
                                             self.experiment.AZ_top_Zotino_channel,
                                             self.experiment.AX_Zotino_channel,
                                             self.experiment.AY_Zotino_channel]

            # dataset names
            self.experiment.measurements_progress = 'measurements_progress'
            self.experiment.SPCM0_rate_dataset = 'SPCM0_counts_per_s'
            self.experiment.SPCM1_rate_dataset = 'SPCM1_counts_per_s'
            self.experiment.scan_var_dataset = "scan_variables"
            self.experiment.scan_sequence1_dataset = "scan_sequence1"
            self.experiment.scan_sequence2_dataset = "scan_sequence2"

            """
            Note that the amplitudes below can be used for setting the urukul channels, but are kernel invariants.
            If you are running the laser_stabilizer in your experiment, and you want to set one of the dds channels we
            feedback to (i.e. it is in one of the dds_feedback_lists in ExperimentVariables), then you should use the
            amplitude attribute of the feedback channel. See subroutines/aom_feedback.py for more details.
            """

            # converts RF power in dBm to amplitudes in V
            self.experiment.ampl_FORT_loading = dB_to_V(self.experiment.p_FORT_loading)
            self.experiment.ampl_cooling_DP_MOT = dB_to_V(self.experiment.p_cooling_DP_MOT)
            self.experiment.ampl_D1_pumping_DP = dB_to_V(self.experiment.p_D1_pumping_DP)
            self.experiment.ampl_pumping_repump = dB_to_V(self.experiment.p_pumping_repump)
            self.experiment.ampl_D1_pumping_DP = dB_to_V(self.experiment.p_D1_pumping_DP)
            self.experiment.ampl_excitation = dB_to_V(self.experiment.p_excitation)
            self.experiment.ampl_microwaves = dB_to_V(self.experiment.p_microwaves)
            self.experiment.ampl_AOM_A1 = dB_to_V(self.experiment.p_AOM_A1)
            self.experiment.ampl_AOM_A2 = dB_to_V(self.experiment.p_AOM_A2)
            self.experiment.ampl_AOM_A3 = dB_to_V(self.experiment.p_AOM_A3)
            self.experiment.ampl_AOM_A4 = dB_to_V(self.experiment.p_AOM_A4)
            self.experiment.ampl_AOM_A5 = dB_to_V(self.experiment.p_AOM_A5)
            self.experiment.ampl_AOM_A6 = dB_to_V(self.experiment.p_AOM_A6)

            # RF powers defined as fractions of the defaults, e.g. the ones we tune during the AOM feedback.
            self.experiment.ampl_FORT_RO = self.experiment.ampl_FORT_loading * self.experiment.p_FORT_RO
            self.experiment.ampl_FORT_PGC = self.experiment.ampl_FORT_loading * self.experiment.p_FORT_PGC
            self.experiment.ampl_FORT_blowaway = self.experiment.ampl_FORT_loading * self.experiment.p_FORT_blowaway
            self.experiment.ampl_FORT_OP = self.experiment.ampl_FORT_loading * self.experiment.p_FORT_OP
            self.experiment.ampl_cooling_DP_RO = self.experiment.ampl_cooling_DP_MOT * self.experiment.p_cooling_DP_RO
            self.experiment.ampl_cooling_DP_PGC = self.experiment.ampl_cooling_DP_MOT * self.experiment.p_cooling_DP_PGC

        elif self.node == "two_nodes":
            # devices without nicknames. core should come first
            devices_no_alias = ["core",
                                "core_dma",
                                "scheduler",
                                "urukul0_cpld", "urukul1_cpld", "urukul2_cpld",
                                "zotino0",  # for controlling coils
                                "sampler0",  # for measuring laser power PD
                                "sampler1", # for reading in volts in the coil tune experiment
                                "sampler2",
                                *[f"ttl{i}" for i in range(16)]]
            for dev in devices_no_alias:
                self.experiment.setattr_device(dev)

            # devices can also be nicknamed here:
            self.experiment.ttl_microwave_switch = self.experiment.ttl4
            self.experiment.ttl_repump_switch = self.experiment.ttl5
            self.experiment.ttl_SPCM0 = self.experiment.ttl0
            self.experiment.ttl_scope_trigger = self.experiment.ttl7
            self.experiment.ttl_Luca_trigger = self.experiment.ttl6
            self.experiment.ttl_UV = self.experiment.ttl15
            self.experiment.ttl_SPCM_gate = self.experiment.ttl13

            # for debugging/logging purposes in experiments
            self.experiment.coil_names = ["AZ bottom","AZ top","AX","AY"]

            self.experiment.AZ_bottom_Zotino_channel = 0
            self.experiment.AZ_top_Zotino_channel = 1
            self.experiment.AX_Zotino_channel = 2
            self.experiment.AY_Zotino_channel = 3

            self.experiment.coil_channels = [self.experiment.AZ_bottom_Zotino_channel,
                                             self.experiment.AZ_top_Zotino_channel,
                                             self.experiment.AX_Zotino_channel,
                                             self.experiment.AY_Zotino_channel]

            # dataset names
            self.experiment.measurements_progress = 'measurements_progress'
            self.experiment.SPCM0_rate_dataset = 'SPCM0_counts_per_s'
            self.experiment.SPCM1_rate_dataset = 'SPCM1_counts_per_s'
            self.experiment.scan_var_dataset = "scan_variables"
            self.experiment.scan_sequence1_dataset = "scan_sequence1"
            self.experiment.scan_sequence2_dataset = "scan_sequence2"

            """
            Note that the amplitudes below can be used for setting the urukul channels, but are kernel invariants.
            If you are running the laser_stabilizer in your experiment, and you want to set one of the dds channels we
            feedback to (i.e. it is in one of the dds_feedback_lists in ExperimentVariables), then you should use the
            amplitude attribute of the feedback channel. See subroutines/aom_feedback.py for more details.
            """

            # converts RF power in dBm to amplitudes in V
            self.experiment.ampl_FORT_loading = dB_to_V(self.experiment.p_FORT_loading)
            self.experiment.ampl_cooling_DP_MOT = dB_to_V(self.experiment.p_cooling_DP_MOT)
            self.experiment.ampl_D1_pumping_DP = dB_to_V(self.experiment.p_D1_pumping_DP)
            self.experiment.ampl_pumping_repump = dB_to_V(self.experiment.p_pumping_repump)
            self.experiment.ampl_D1_pumping_DP = dB_to_V(self.experiment.p_D1_pumping_DP)
            self.experiment.ampl_excitation = dB_to_V(self.experiment.p_excitation)
            self.experiment.ampl_microwaves = dB_to_V(self.experiment.p_microwaves)
            self.experiment.ampl_AOM_A1 = dB_to_V(self.experiment.p_AOM_A1)
            self.experiment.ampl_AOM_A2 = dB_to_V(self.experiment.p_AOM_A2)
            self.experiment.ampl_AOM_A3 = dB_to_V(self.experiment.p_AOM_A3)
            self.experiment.ampl_AOM_A4 = dB_to_V(self.experiment.p_AOM_A4)
            self.experiment.ampl_AOM_A5 = dB_to_V(self.experiment.p_AOM_A5)
            self.experiment.ampl_AOM_A6 = dB_to_V(self.experiment.p_AOM_A6)

            # RF powers defined as fractions of the defaults, e.g. the ones we tune during the AOM feedback.
            self.experiment.ampl_FORT_RO = self.experiment.ampl_FORT_loading * self.experiment.p_FORT_RO
            self.experiment.ampl_FORT_PGC = self.experiment.ampl_FORT_loading * self.experiment.p_FORT_PGC
            self.experiment.ampl_FORT_blowaway = self.experiment.ampl_FORT_loading * self.experiment.p_FORT_blowaway
            self.experiment.ampl_FORT_OP = self.experiment.ampl_FORT_loading * self.experiment.p_FORT_OP
            self.experiment.ampl_cooling_DP_RO = self.experiment.ampl_cooling_DP_MOT * self.experiment.p_cooling_DP_RO
            self.experiment.ampl_cooling_DP_PGC = self.experiment.ampl_cooling_DP_MOT * self.experiment.p_cooling_DP_PGC
        else:
            raise KeyError

        # functions
        @rpc(flags={"async"})
        def print_async(*x):
            """print asynchronously so we don't block the RTIO counter.
            useful for debugging"""
            print(*x)

        self.experiment.print_async = print_async

        def write_results_wrapper(kwargs={}):
            write_results(experiment=self.experiment, **kwargs)

        self.experiment.write_results = write_results_wrapper

        # THIS MUST COME LAST IN BASE.BUILD
        # get a list of all attributes of experiment up to this point. if base.build is called in your experiment
        # before any GUI arguments are defined, then this can be used to grab those later by taking a difference
        self.exp_var_names = dir(self.experiment)
        logging.debug("base build - done")


    def set_datasets_from_gui_args(self):
        """
        This should be called at the end of your experiment's build method to archive the GUI arguments.

        For this to work, it is assumed that the line 'self.exp_var_names = dir(self.experiment)' comes
        last in base.build above.
        :return:
        """
        new_exp_var_names = [x for x in dir(self.experiment) if x not in self.exp_var_names]
        for name in new_exp_var_names:
            try:
                self.experiment.set_dataset(name, getattr(self.experiment, name))
            except Exception as e:
                logging.debug(e)

    def prepare(self):
        """
        Initialize DeviceAliases, compute DDS amplitudes from powers, instantiate the laser servo,
        any other math that needs to happen before we run stuff on the kernel.

        The main difference between Base.build and Base.prepare is that build should contain things we only
        want to happen once per experiment, whereas we might want to call prepare each iteration to reinitialize
        things pertaining to hardware.

        :return:
        """

        # node independent stuff

        # set the variables again. because prepare may be called multiple times, e.g. in GeneralVariableScan,
        # we want to make sure we load up the most recent datasets. this also allows us to change datasets on the fly
        # from the dashboard while the experiment is running.

        self.experiment.Rigol_modulation_volts = 0.0

        self.experiment.advance = 1

        # i don't think this is getting the most recent value of the dataset.
        # exclude_keywords = ['history']  # for autogenerated datasets so we don't have to remember to add variables later
        # setattr_variables(self.experiment, exclude_list=[], exclude_keywords=exclude_keywords)

        if self.node == "alice":
            # initialize named channels.
            self.experiment.named_devices = DeviceAliases(
                experiment=self.experiment,
                device_aliases=[
                    'dds_FORT',
                    'dds_D1_pumping_DP',
                    'dds_cooling_DP',
                    'dds_pumping_repump',
                    'dds_excitation',
                    'dds_microwaves',
                    *[f'dds_AOM_A{i + 1}' for i in range(6)]  # the fiber AOMs
                ]
            )

            # this is an attribute of of the experiment in case we want to access it elsewhere
            self.experiment.all_dds_channels = [getattr(self.experiment, f'urukul{card}_ch{channel}')
                                                for card in range(3) for channel in range(4)]

            # convert times to machine units
            seconds_to_mu = self.experiment.core.seconds_to_mu
            self.experiment.t_MOT_loading_mu = seconds_to_mu(self.experiment.t_MOT_loading)
            self.experiment.t_FORT_loading_mu = seconds_to_mu(self.experiment.t_FORT_loading)
            self.experiment.t_SPCM_exposure_mu = seconds_to_mu(self.experiment.t_SPCM_exposure)

            # mainly for cost functions
            try:
                self.experiment.SPCM0_RO1_list = [0] * self.experiment.n_measurements
                self.experiment.SPCM0_RO2_list = [0] * self.experiment.n_measurements
                self.experiment.SPCM1_RO1_list = [0] * self.experiment.n_measurements
                self.experiment.SPCM1_RO2_list = [0] * self.experiment.n_measurements

            except:
                # if this fails, your experiment probably didn't need it
                self.experiment.print_async("experiment does not have variable n_measurements")
                # logging.warn("experiment does not have variable n_measurements")

            slow_feedback_dds_list = eval(self.experiment.slow_feedback_dds_list)
            fast_feedback_dds_list = eval(self.experiment.fast_feedback_dds_list)

            # could implement this but it isn't needed right now
            # self.experiment.slow_laser_stabilizer = AOMPowerStabilizer(experiment=self.experiment,
            #                                                       dds_names=slow_feedback_dds_list,
            #                                                       iterations=self.experiment.aom_feedback_iterations,
            #                                                       averages=self.experiment.aom_feedback_averages,
            #                                                       leave_AOMs_on=True)

            # feedback channels which are fast enough to include on every atom loading attempt.
            # this excludes things which use fW detectors which have slow rise time.
            self.experiment.laser_stabilizer = AOMPowerStabilizer(experiment=self.experiment,
                                                                  dds_names=fast_feedback_dds_list,
                                                                  iterations=self.experiment.aom_feedback_iterations,
                                                                  averages=self.experiment.aom_feedback_averages,
                                                                  leave_AOMs_on=False,
                                                                  leave_MOT_AOMs_on=True)

            # todo: make OP feedback list in ExperimentVariables, so we can feedback to this separately.
            #  this allows us to feedback to D1, pumping repump, etc every iteration instead of every measurement.
            # self.experiment.OP_laser_stabilizer = AOMPowerStabilizer(experiment=self.experiment,
            #                                                       dds_names=OP_feedback_dds_list,
            #                                                       iterations=self.experiment.aom_feedback_iterations,
            #                                                       averages=self.experiment.aom_feedback_averages,
            #                                                       leave_AOMs_on=False,
            #                                                       leave_MOT_AOMs_on=True)

            self.experiment.set_dataset("feedbackchannels",
                             [ch.dB_dataset for ch in self.experiment.laser_stabilizer.all_channels],
                             broadcast=True, persist=True)

            self.experiment.initial_RF_dB_values = np.zeros(len(fast_feedback_dds_list))
            for ch_i, ch in enumerate(self.experiment.laser_stabilizer.all_channels):
                self.experiment.initial_RF_dB_values[ch_i] = self.experiment.get_dataset(ch.dB_dataset, archive=False)
                try:
                    # self.experiment.get_dataset(self.experiment.laser_stabilizer.all_channels[ch_i].dB_history_dataset,
                    #                             archive=False)
                    self.experiment.append_to_dataset(
                        self.experiment.laser_stabilizer.all_channels[ch_i].dB_history_dataset,
                        float(self.experiment.initial_RF_dB_values[ch_i]))

                except KeyError:
                    self.experiment.set_dataset(self.experiment.laser_stabilizer.all_channels[ch_i].dB_history_dataset,
                                     [float(self.experiment.initial_RF_dB_values[ch_i])], broadcast=True)
        elif self.node == "bob":
            # initialize named channels.
            self.experiment.named_devices = DeviceAliases(
                experiment=self.experiment,
                device_aliases=[
                    'dds_FORT',
                    'dds_D1_pumping_DP',
                    'dds_cooling_DP',
                    'dds_pumping_repump',
                    'dds_excitation',
                    'dds_microwaves',
                    *[f'dds_AOM_A{i + 1}' for i in range(6)]  # the fiber AOMs
                ]
            )

            # this is an attribute of of the experiment in case we want to access it elsewhere
            self.experiment.all_dds_channels = [getattr(self.experiment, f'urukul{card}_ch{channel}')
                                                for card in range(3) for channel in range(4)]

            # convert times to machine units
            seconds_to_mu = self.experiment.core.seconds_to_mu
            self.experiment.t_MOT_loading_mu = seconds_to_mu(self.experiment.t_MOT_loading)
            self.experiment.t_FORT_loading_mu = seconds_to_mu(self.experiment.t_FORT_loading)
            self.experiment.t_SPCM_exposure_mu = seconds_to_mu(self.experiment.t_SPCM_exposure)

            # mainly for cost functions
            try:
                self.experiment.SPCM0_RO1_list = [0] * self.experiment.n_measurements
                self.experiment.SPCM0_RO2_list = [0] * self.experiment.n_measurements
                self.experiment.SPCM1_RO1_list = [0] * self.experiment.n_measurements
                self.experiment.SPCM1_RO2_list = [0] * self.experiment.n_measurements
            except:
                # if this fails, your experiment probably didn't need it
                self.experiment.print_async("experiment does not have variable n_measurements")
                # logging.warn("experiment does not have variable n_measurements")

            slow_feedback_dds_list = eval(self.experiment.slow_feedback_dds_list)
            fast_feedback_dds_list = eval(self.experiment.fast_feedback_dds_list)

            # could implement this but it isn't needed right now
            # self.experiment.slow_laser_stabilizer = AOMPowerStabilizer(experiment=self.experiment,
            #                                                       dds_names=slow_feedback_dds_list,
            #                                                       iterations=self.experiment.aom_feedback_iterations,
            #                                                       averages=self.experiment.aom_feedback_averages,
            #                                                       leave_AOMs_on=True)

            # feedback channels which are fast enough to include on every atom loading attempt.
            # this excludes things which use fW detectors which have slow rise time.
            self.experiment.laser_stabilizer = AOMPowerStabilizer(experiment=self.experiment,
                                                                  dds_names=fast_feedback_dds_list,
                                                                  iterations=self.experiment.aom_feedback_iterations,
                                                                  averages=self.experiment.aom_feedback_averages,
                                                                  leave_AOMs_on=False,
                                                                  leave_MOT_AOMs_on=True)

            self.experiment.set_dataset("feedbackchannels",
                                        [ch.dB_dataset for ch in self.experiment.laser_stabilizer.all_channels],
                                        broadcast=True, persist=True)

            self.experiment.initial_RF_dB_values = np.zeros(len(fast_feedback_dds_list))
            for ch_i, ch in enumerate(self.experiment.laser_stabilizer.all_channels):
                self.experiment.initial_RF_dB_values[ch_i] = self.experiment.get_dataset(ch.dB_dataset, archive=False)
                try:
                    # self.experiment.get_dataset(self.experiment.laser_stabilizer.all_channels[ch_i].dB_history_dataset,
                    #                             archive=False)
                    self.experiment.append_to_dataset(
                        self.experiment.laser_stabilizer.all_channels[ch_i].dB_history_dataset,
                        float(self.experiment.initial_RF_dB_values[ch_i]))

                except KeyError:
                    self.experiment.set_dataset(self.experiment.laser_stabilizer.all_channels[ch_i].dB_history_dataset,
                                                [float(self.experiment.initial_RF_dB_values[ch_i])], broadcast=True)
        elif self.node == "two_nodes":
            # initialize named channels.
            self.experiment.named_devices = DeviceAliases(
                experiment=self.experiment,
                device_aliases=[
                    'dds_FORT',
                    'dds_D1_pumping_DP',
                    'dds_cooling_DP',
                    'dds_pumping_repump',
                    'dds_excitation',
                    'dds_microwaves',
                    *[f'dds_AOM_A{i + 1}' for i in range(6)]  # the fiber AOMs
                ]
            )

            # this is an attribute of of the experiment in case we want to access it elsewhere
            self.experiment.all_dds_channels = [getattr(self.experiment, f'urukul{card}_ch{channel}')
                                                for card in range(3) for channel in range(4)]

            # convert times to machine units
            seconds_to_mu = self.experiment.core.seconds_to_mu
            self.experiment.t_MOT_loading_mu = seconds_to_mu(self.experiment.t_MOT_loading)
            self.experiment.t_FORT_loading_mu = seconds_to_mu(self.experiment.t_FORT_loading)
            self.experiment.t_SPCM_exposure_mu = seconds_to_mu(self.experiment.t_SPCM_exposure)

            # mainly for cost functions
            try:
                self.experiment.SPCM0_RO1_list = [0] * self.experiment.n_measurements
                self.experiment.SPCM0_RO2_list = [0] * self.experiment.n_measurements
                self.experiment.SPCM1_RO1_list = [0] * self.experiment.n_measurements
                self.experiment.SPCM1_RO2_list = [0] * self.experiment.n_measurements
            except:
                # if this fails, your experiment probably didn't need it
                self.experiment.print_async("experiment does not have variable n_measurements")
                # logging.warn("experiment does not have variable n_measurements")

            slow_feedback_dds_list = eval(self.experiment.slow_feedback_dds_list)
            fast_feedback_dds_list = eval(self.experiment.fast_feedback_dds_list)

            # could implement this but it isn't needed right now
            # self.experiment.slow_laser_stabilizer = AOMPowerStabilizer(experiment=self.experiment,
            #                                                       dds_names=slow_feedback_dds_list,
            #                                                       iterations=self.experiment.aom_feedback_iterations,
            #                                                       averages=self.experiment.aom_feedback_averages,
            #                                                       leave_AOMs_on=True)

            # feedback channels which are fast enough to include on every atom loading attempt.
            # this excludes things which use fW detectors which have slow rise time.
            self.experiment.laser_stabilizer = AOMPowerStabilizer(experiment=self.experiment,
                                                                  dds_names=fast_feedback_dds_list,
                                                                  iterations=self.experiment.aom_feedback_iterations,
                                                                  averages=self.experiment.aom_feedback_averages,
                                                                  leave_AOMs_on=False,
                                                                  leave_MOT_AOMs_on=True)

            self.experiment.set_dataset("feedbackchannels",
                                        [ch.dB_dataset for ch in self.experiment.laser_stabilizer.all_channels],
                                        broadcast=True, persist=True)

            self.experiment.initial_RF_dB_values = np.zeros(len(fast_feedback_dds_list))
            for ch_i, ch in enumerate(self.experiment.laser_stabilizer.all_channels):
                self.experiment.initial_RF_dB_values[ch_i] = self.experiment.get_dataset(ch.dB_dataset, archive=False)
                try:
                    # self.experiment.get_dataset(self.experiment.laser_stabilizer.all_channels[ch_i].dB_history_dataset,
                    #                             archive=False)
                    self.experiment.append_to_dataset(
                        self.experiment.laser_stabilizer.all_channels[ch_i].dB_history_dataset,
                        float(self.experiment.initial_RF_dB_values[ch_i]))

                except KeyError:
                    self.experiment.set_dataset(self.experiment.laser_stabilizer.all_channels[ch_i].dB_history_dataset,
                                                [float(self.experiment.initial_RF_dB_values[ch_i])], broadcast=True)
        else:
            raise KeyError

        logging.debug("base prepare - done")

    def initialize_datasets(self):
        """
        Initialize datasets which are common to many experiments
        :return:
        """
        self.experiment.set_dataset("iteration", 0, broadcast=True)
        self.experiment.set_dataset("n_measurements", self.experiment.n_measurements, broadcast=True)
        self.experiment.set_dataset("SPCM0_RO1", [0], broadcast=True)
        self.experiment.set_dataset("SPCM0_RO2", [0], broadcast=True)
        self.experiment.set_dataset("SPCM1_RO1", [0], broadcast=True)
        self.experiment.set_dataset("SPCM1_RO2", [0], broadcast=True)
        self.experiment.set_dataset("photocount_bins", [50], broadcast=True)
        self.experiment.set_dataset("SPCM0_FORT_science", [0.0], broadcast=True)
        self.experiment.set_dataset("FORT_MM_science_volts", [0.0], broadcast=True)
        self.experiment.set_dataset("SPCM0_SinglePhoton", [0], broadcast=True)
        self.experiment.set_dataset("SPCM1_SinglePhoton", [0], broadcast=True)
        self.experiment.set_dataset("SPCM0_every_exc_RO", [0], broadcast=True)


        self.experiment.set_dataset("GRIN1_D1_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("GRIN1_EXC_monitor", [0.0], broadcast=True)

        self.experiment.set_dataset("REPUMP1_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("REPUMP2_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("REPUMP3_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("REPUMP4_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("REPUMP5_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("REPUMP6_monitor", [0.0], broadcast=True)

        self.experiment.set_dataset("PUMPING_REPUMP1_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("PUMPING_REPUMP2_monitor", [0.0], broadcast=True)

        self.experiment.set_dataset("MOT1_end_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("MOT2_end_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("MOT3_end_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("MOT4_end_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("MOT5_end_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("MOT6_end_monitor", [0.0], broadcast=True)

        self.experiment.set_dataset("zotino_test1_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("zotino_test2_monitor", [0.0], broadcast=True)

    @kernel
    def initialize_hardware(self, turn_off_dds_channels=True, turn_off_zotinos=True):
        """
        hardware initialization and setting of ttl switches, and set datasets

        'turn_off_dds_channels': will turn off all Urukul channel outputs if True (default).
        'turn_off_zotinos': will set all Zotino channels to 0*V if True (default).
        :return:
        """

        if self.node == "alice":
            self.experiment.core.reset()

            self.experiment.set_dataset(self.experiment.measurements_progress,0.0,broadcast=True)
            self.experiment.set_dataset(self.experiment.scan_var_dataset,'',broadcast=True)
            self.experiment.set_dataset(self.experiment.scan_sequence1_dataset,[0.0],broadcast=True)
            self.experiment.set_dataset(self.experiment.scan_sequence2_dataset,[0.0],broadcast=True)

            self.experiment.named_devices.initialize()

            self.experiment.ttl_microwave_switch.output()
            self.experiment.ttl_repump_switch.output()
            self.experiment.ttl_scope_trigger.output()
            # self.experiment.ttl6.output()  # for outputting a trigger
            self.experiment.ttl_exc0_switch.output()
            self.experiment.ttl1.input()

            self.experiment.ttl_D1_lock_monitor.input()

            # for diagnostics including checking the performance of fast switches for SPCM gating
            self.experiment.ttl9.output()
            delay(1 * ms)
            self.experiment.ttl9.off()

            self.experiment.ttl_UV.output()
            delay(1*ms)
            self.experiment.ttl_UV.off()

            # ttl channel for toggling between what we send to the VCA: the zotino voltage or the Rigol signal
            # for modulating the FORT
            self.experiment.FORT_mod_switch.output()
            delay(1*ms)
            self.experiment.FORT_mod_switch.off() # off = no modulation

            self.experiment.sampler0.init() # for reading laser feedback
            self.experiment.sampler1.init() # for reading laser feedback
            self.experiment.sampler2.init() # for reading laser feedback

            # turn on/off any switches. this ensures that switches always start in a default state,
            # which might not happen if we abort an experiment in the middle and don't reset it
            self.experiment.ttl_exc0_switch.on()   # blocks excitation
            delay(1*ms)
            self.experiment.ttl_repump_switch.off() # allow RF to get to the RP AOM
            delay(1*ms)
            self.experiment.ttl_microwave_switch.on() # blocks the microwaves after the mixer
            delay(1*ms)
            self.experiment.ttl_SPCM_gate.off() # unblocks the SPCM output

            if turn_off_zotinos:
                self.experiment.zotino0.init()
                for zot_ch in range(32):
                    self.experiment.zotino0.write_dac(zot_ch, 0.0)
                    self.experiment.zotino0.load()
                    delay(1 * ms)

            if turn_off_dds_channels:
                for dds_ch in self.experiment.all_dds_channels:
                    dds_ch.sw.off()
                    delay(1*ms)

            self.experiment.zotino0.write_dac(5, 0.62)  # turn on the VCA for the FORT
            self.experiment.zotino0.load()
            delay(1 * ms)

            self.experiment.core.break_realtime()
        elif self.node == "bob":
            self.experiment.core.reset()

            self.experiment.set_dataset(self.experiment.measurements_progress,0.0,broadcast=True)
            self.experiment.set_dataset(self.experiment.scan_var_dataset,'',broadcast=True)
            self.experiment.set_dataset(self.experiment.scan_sequence1_dataset,[0.0],broadcast=True)
            self.experiment.set_dataset(self.experiment.scan_sequence2_dataset,[0.0],broadcast=True)

            self.experiment.named_devices.initialize()

            self.experiment.ttl_microwave_switch.output()
            self.experiment.ttl_repump_switch.output()
            self.experiment.ttl6.output()  # for outputting a trigger
            self.experiment.ttl1.input()

            # for diagnostics including checking the performance of fast switches for SPCM gating
            self.experiment.ttl9.output()
            delay(1 * ms)
            self.experiment.ttl9.off()

            self.experiment.ttl_UV.output()
            self.experiment.ttl_UV.off()

            self.experiment.sampler0.init() # for reading laser feedback
            self.experiment.sampler1.init() # for reading laser feedback
            self.experiment.sampler2.init() # for reading laser feedback

            # turn on/off any switches. this ensures that switches always start in a default state,
            # which might not happen if we abort an experiment in the middle and don't reset it
            self.experiment.ttl_repump_switch.off() # allow RF to get to the RP AOM
            delay(1*ms)
            self.experiment.ttl_microwave_switch.on() # blocks the microwaves after the mixer
            delay(1*ms)
            self.experiment.ttl_SPCM_gate.off() # unblocks the SPCM output

            if turn_off_zotinos:
                self.experiment.zotino0.init()
                for zot_ch in range(32):
                    self.experiment.zotino0.write_dac(zot_ch, 0.0)
                    self.experiment.zotino0.load()
                    delay(1 * ms)

            if turn_off_dds_channels:
                for dds_ch in self.experiment.all_dds_channels:
                    dds_ch.sw.off()
                    delay(1 * ms)

            self.experiment.core.break_realtime()
        elif self.node == "two_nodes":
            self.experiment.core.reset()

            self.experiment.set_dataset(self.experiment.measurements_progress,0.0,broadcast=True)
            self.experiment.set_dataset(self.experiment.scan_var_dataset,'',broadcast=True)
            self.experiment.set_dataset(self.experiment.scan_sequence1_dataset,[0.0],broadcast=True)
            self.experiment.set_dataset(self.experiment.scan_sequence2_dataset,[0.0],broadcast=True)

            self.experiment.named_devices.initialize()

            self.experiment.ttl_microwave_switch.output()
            self.experiment.ttl_repump_switch.output()
            self.experiment.ttl6.output()  # for outputting a trigger
            self.experiment.ttl1.input()

            # for diagnostics including checking the performance of fast switches for SPCM gating
            self.experiment.ttl9.output()
            delay(1 * ms)
            self.experiment.ttl9.off()

            self.experiment.ttl_UV.output()
            self.experiment.ttl_UV.off()

            self.experiment.sampler0.init() # for reading laser feedback
            self.experiment.sampler1.init() # for reading laser feedback
            self.experiment.sampler2.init() # for reading laser feedback

            # turn on/off any switches. this ensures that switches always start in a default state,
            # which might not happen if we abort an experiment in the middle and don't reset it
            self.experiment.ttl_repump_switch.off() # allow RF to get to the RP AOM
            delay(1*ms)
            self.experiment.ttl_microwave_switch.on() # blocks the microwaves after the mixer
            delay(1*ms)
            self.experiment.ttl_SPCM_gate.off() # unblocks the SPCM output

            if turn_off_zotinos:
                self.experiment.zotino0.init()
                for zot_ch in range(32):
                    self.experiment.zotino0.write_dac(zot_ch, 0.0)
                    self.experiment.zotino0.load()
                    delay(1 * ms)

            if turn_off_dds_channels:
                for dds_ch in self.experiment.all_dds_channels:
                    dds_ch.sw.off()
                    delay(1 * ms)

            self.experiment.core.break_realtime()
        
        self.experiment.print_async("initialize hardware - done")


# do this so the code above will not actually run when ARTIQ scans the repository
if __name__ == '__main__':
    pass


