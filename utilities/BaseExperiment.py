"""
Setup for a "base experiment".

To allow us to be flexible with the type of ARTIQ we run in the future,
we do not inherit from an artiq experiment, but add variables and devices
as attributes to an experiment passed by reference to the functions below.

There are also some quality of life functions here.

intended usage:
----
from BaseExperiment import BaseExperiment


class MyExp(EnvExperiment):

    def build:
        # gets variables and devices
        self.base = BaseExperiment(experiment=self)
        self.base.build()

        # define GUI arguments here
        self.setattr_argument("my_argument",NumberValue(5))

        self.base.set_datasets_from_gui_args()

    def prepare:
        self.base.prepare()

    @kernel
    def run:
        self.base.initialize_hardware()
        # now we can do physics

        # reference devices and variables which were initialized in the base experiment
        self.dds_AOM_A1.sw.on()
        self.ttl6.pulse(self.t_pulse)
----
"""
from artiq.experiment import *
from artiq.language import us, ns, MHz
import logging
import numpy as np
from numpy import inf
import sys, os
import json
import math


cwd = os.getcwd() + "\\"
sys.path.append(cwd)
sys.path.append(cwd+"\\repository\\qn_artiq_routines")

from subroutines.aom_feedback import AOMPowerStabilizer
from ExperimentVariables import setattr_variables
from utilities.DeviceAliases import DeviceAliases
from utilities.write_h5 import write_results
from utilities.conversions import dB_to_V
# from K10CR1.KinesisMotorWrapper import KinesisMotorWrapper
from subroutines.k10cr1_functions import *

import os

cwd = os.getcwd() # must be called here. if called in class, returns the results level dir


class BaseExperiment:

    def __init__(self, experiment: EnvExperiment):
        """
        Instantiate BaseExperiment in your build method, with experiment=self
        :param experiment: an instance of an ARTIQ Experiment.
        """
        self.node = experiment.get_dataset("which_node")
        self.experiment = experiment

        devices_file = os.path.join(cwd, "repository\\qn_artiq_routines\\utilities\\config\\",
                                    self.node,
                                    "device_aliases.json")

        with open(devices_file) as f:
            devices_dict = json.load(f)
            self.experiment.alias_map = devices_dict["ALIAS_MAP"]
            self.experiment.dds_defaults = devices_dict["DDS_DEFAULTS"]

    def build(self):
        """
        Put this in your experiment's build method

        Assigning attributes and methods to the experiment should be done here.

        The main difference between Base.build and Base.prepare is that build should contain things we only
        want to happen once per experiment, whereas we might want to call prepare each iteration to reinitialize
        things pertaining to hardware.

        :param experiment: your experiment.
        :return:
        """

        with open(os.path.join(cwd,'dataset_db.pyon')) as f:
            datasets_str = f.read()

        ### when the pyon file is saved python True and False are converted to lowercase...
        datasets_str = datasets_str.replace("true", "True")
        datasets_str = datasets_str.replace("false", "False")
        datasets_dict = eval(datasets_str)

        ### these are the names of all of the datasets, which we're going to use to create attributes of the same name
        self.experiment.variables = datasets_dict.keys()

        ### we don't want to try to add long lists as experiment attributes. this can result in timeout exceptions.
        exclude_keywords = ['history']# for autogenerated datasets so we don't have to remember to add variables later
        setattr_variables(self.experiment, exclude_list=[], exclude_keywords=exclude_keywords)

        self.experiment.SPCM0_RO1 = 0
        self.experiment.SPCM0_RO2 = 0
        self.experiment.SPCM1_RO1 = 0
        self.experiment.SPCM1_RO2 = 0
        self.experiment.BothSPCMs_RO1 = 0
        self.experiment.BothSPCMs_RO2 = 0
        self.experiment.BothSPCMs_parity_RO = 0
        self.experiment.SPCM0_test_RO = 0
        self.experiment.atom_loading_time = 0.0

        self.experiment.SPCM0_FORT_science = 0
        self.experiment.measurement = 0
        self.experiment.ro_dma_handle = (np.int32(0), np.int64(0), np.int32(0))
        self.experiment.ro_dma_handle2 = (np.int32(0), np.int64(0), np.int32(0))

        self.experiment.n_feedback_per_iteration = 0
        self.experiment.n_atom_loaded_per_iteration = 0

        self.experiment.FORT_step_size = 1
        self.experiment.FORT_total_points = 1
        self.experiment.FORT_amplitudes_list = [0]

        if self.node == "alice":
            ### devices without nicknames. core should come first
            devices_no_alias = ["core",
                                "core_dma",
                                "scheduler",
                                "urukul0_cpld", "urukul1_cpld", "urukul2_cpld",
                                "zotino0",  # for controlling coils
                                "sampler0",  # for measuring laser power PD
                                "sampler1", # for reading in volts in the coil tune experiment
                                "sampler2",
                                *[f"ttl{i}" for i in range(16)],
                                *[f"ttl{i}_counter" for i in range(4)],  # ttl card 0 edge counters
                                *[f"ttl{i}_counter" for i in range(8, 12)]]  # ttl card 1 edge counters

            for dev in devices_no_alias:
                self.experiment.setattr_device(dev)

            # ndsp devices
            try:
                self.experiment.setattr_device("k10cr1_ndsp")
            except Exception as e:
                print(f"Error connecting to device {e}")

            # devices can also be nicknamed here:
            # todo: do this in the device_db
            # ttl0~3
            self.experiment.ttl_SPCM0 = self.experiment.ttl0
            self.experiment.ttl_SPCM0_counter = self.experiment.ttl0_counter
            self.experiment.ttl_SPCM1 = self.experiment.ttl1
            self.experiment.ttl_SPCM1_counter = self.experiment.ttl1_counter

            ### ttl4~7
            self.experiment.ttl_microwave_switch = self.experiment.ttl4
            self.experiment.ttl_repump_switch = self.experiment.ttl5
            # self.experiment.ttl_Luca_trigger = self.experiment.ttl6 # Luca no longer used.
            self.experiment.ttl_exc0_switch = self.experiment.ttl6
            self.experiment.ttl_pumping_repump_switch = self.experiment.ttl7

            ### ttl8~11
            self.experiment.ttl_D1_lock_monitor = self.experiment.ttl8

            ### ttl12~15
            self.experiment.ttl_D1_pumping = self.experiment.ttl11 ### not used in node 1. Just to avoid error.
            self.experiment.FORT_mod_switch = self.experiment.ttl11 ### should be on ttl12 when we need this to measure trap freq.
            self.experiment.ttl_SPCM0_logic = self.experiment.ttl12
            self.experiment.ttl_SPCM1_logic = self.experiment.ttl15
            self.experiment.ttl_GRIN2_switch = self.experiment.ttl13
            self.experiment.ttl_GRIN1_switch = self.experiment.ttl14

            ### for debugging/logging purposes in experiments
            self.experiment.coil_names = ["AZ bottom","AZ top","AX","AY"]

            self.experiment.AZ_bottom_Zotino_channel = 0
            self.experiment.AZ_top_Zotino_channel = 1
            self.experiment.AX_Zotino_channel = 2
            self.experiment.AY_Zotino_channel = 3

            self.experiment.coil_channels = [self.experiment.AZ_bottom_Zotino_channel,
                                             self.experiment.AZ_top_Zotino_channel,
                                             self.experiment.AX_Zotino_channel,
                                             self.experiment.AY_Zotino_channel]

            self.experiment.UV_trig_channel = [8]
            self.experiment.Osc_trig_channel = [10]

            self.experiment.FORT_MM_sampler_ch = 7
            self.experiment.GRIN1_sampler_ch = 4  # Sampler1; function "measure_GRIN1" in experiment functions.py

            self.experiment.Magnetometer_X_ch = 1 ### Magnetometer is connected to Sampler2
            self.experiment.Magnetometer_Y_ch = 2
            self.experiment.Magnetometer_Z_ch = 3

            ### for zotino stability test
            # self.zotino_test_1_Zotino_channel = 6  # Zotino 0 - ch6
            # self.zotino_test_2_Zotino_channel = 7  # Zotino 0 - ch7
            # self.experiment.zotino_test_channels = [self.zotino_test_1_Zotino_channel, self.zotino_test_2_Zotino_channel]


            ### dataset names
            self.experiment.measurements_progress = 'measurements_progress'
            self.experiment.SPCM0_rate_dataset = 'SPCM0_counts_per_s'
            self.experiment.SPCM1_rate_dataset = 'SPCM1_counts_per_s'
            self.experiment.BothSPCMs_rate_dataset = 'BothSPCMs_counts_per_s'
            self.experiment.scan_var_dataset = "scan_variables"
            self.experiment.scan_sequence1_dataset = "scan_sequence1"
            self.experiment.scan_sequence2_dataset = "scan_sequence2"

            """
            Note that the amplitudes below can be used for setting the urukul channels, but are kernel invariants.
            If you are running the laser_stabilizer in your experiment, and you want to set one of the dds channels we
            feedback to (i.e. it is in one of the dds_feedback_lists in ExperimentVariables), then you should use the
            amplitude attribute of the feedback channel. See subroutines/aom_feedback.py for more details.
            """

            ### converts RF power in dBm to amplitudes in V
            self.experiment.ampl_FORT_loading = dB_to_V(self.experiment.p_FORT_loading) # used only for old experiments
            self.experiment.ampl_cooling_DP_MOT = dB_to_V(self.experiment.p_cooling_DP_MOT)

            ### RF powers defined as fractions of the defaults - warning: the AOM response isn't linear like this
            self.experiment.ampl_FORT_RO = self.experiment.ampl_FORT_loading * self.experiment.p_FORT_RO
            self.experiment.ampl_FORT_PGC = self.experiment.ampl_FORT_loading * self.experiment.p_FORT_PGC
            self.experiment.ampl_FORT_blowaway = self.experiment.ampl_FORT_loading * self.experiment.p_FORT_blowaway
            self.experiment.ampl_FORT_OP = self.experiment.ampl_FORT_loading * self.experiment.p_FORT_OP
            self.experiment.ampl_cooling_DP_RO = self.experiment.ampl_cooling_DP_MOT * self.experiment.p_cooling_DP_RO
            self.experiment.ampl_cooling_DP_PGC = self.experiment.ampl_cooling_DP_MOT * self.experiment.p_cooling_DP_PGC

        elif self.node == "bob":
            ### devices without nicknames. core should come first
            devices_no_alias = ["core",
                                "core_dma",
                                "scheduler",
                                "urukul0_cpld", "urukul1_cpld", "urukul2_cpld",
                                "zotino0",  # for controlling coils
                                "sampler0",  # for measuring laser power PD
                                "sampler1", # for reading in volts in the coil tune experiment
                                "sampler2",
                                *[f"ttl{i}" for i in range(16)],
                                *[f"ttl{i}_counter" for i in range(4)],         # ttl card 0 edge counters
                                *[f"ttl{i}_counter" for i in range(8, 12)]]      # ttl card 1 edge counters

            for dev in devices_no_alias:
                self.experiment.setattr_device(dev)

            ### ndsp devices
            try:
                self.experiment.setattr_device("k10cr1_ndsp")
            except Exception as e:
                print(f"Error connecting to device {e}")



            ### devices can also be nicknamed here:
            ### todo: do this in the device_db

            ### ttl0~3
            self.experiment.ttl_SPCM0 = self.experiment.ttl0   # SPCM2
            self.experiment.ttl_SPCM0_counter = self.experiment.ttl0_counter   # SPCM2 counter
            self.experiment.ttl_SPCM1 = self.experiment.ttl1   # SPCM3
            self.experiment.ttl_SPCM1_counter = self.experiment.ttl1_counter   # SPCM3 counter

            ### ttl4~7
            self.experiment.ttl_microwave_switch = self.experiment.ttl4
            self.experiment.ttl_repump_switch = self.experiment.ttl5
            self.experiment.ttl_exc0_switch = self.experiment.ttl6
            self.experiment.ttl_pumping_repump_switch = self.experiment.ttl7

            ### ttl8~11
            self.experiment.ttl_D1_lock_monitor = self.experiment.ttl8
            self.experiment.FORT_mod_switch = self.experiment.ttl11

            ### ttl12~15
            self.experiment.ttl_D1_pumping = self.experiment.ttl12
            self.experiment.ttl_GRIN2_switch = self.experiment.ttl13
            self.experiment.ttl_GRIN1_switch = self.experiment.ttl14

            ### in experiment_functions.py, measure_FORT_MM_fiber() function
            ### BOB: IF FORT feedback use APD, make sure to change MM smapler ch & APD sampler ch in BaseExperiment.py

            self.experiment.FORT_MM_sampler_ch = 7 # SAMPLER 1 for BOB also.
            # ##Sampler1; function "measure_GRIN1" in experiment functions.py
            self.experiment.GRIN1_sampler_ch = 4  # to avoid error. not implemented in node2



            ### for debugging/logging purposes in experiments
            self.experiment.coil_names = ["AZ bottom","AZ top","AX","AY"]

            self.experiment.AZ_bottom_Zotino_channel = 0
            self.experiment.AZ_top_Zotino_channel = 1
            self.experiment.AX_Zotino_channel = 2
            self.experiment.AY_Zotino_channel = 3

            self.experiment.coil_channels = [self.experiment.AZ_bottom_Zotino_channel,
                                             self.experiment.AZ_top_Zotino_channel,
                                             self.experiment.AX_Zotino_channel,
                                             self.experiment.AY_Zotino_channel]

            self.experiment.UV_trig_channel = [8]
            self.experiment.Osc_trig_channel = [10]

            self.experiment.Magnetometer_X_ch = 1  ### Magnetometer is connected to Sampler2
            self.experiment.Magnetometer_Y_ch = 2
            self.experiment.Magnetometer_Z_ch = 3

            ### dataset names
            self.experiment.measurements_progress = 'measurements_progress'
            self.experiment.SPCM0_rate_dataset = 'SPCM0_counts_per_s'
            self.experiment.SPCM1_rate_dataset = 'SPCM1_counts_per_s'
            self.experiment.BothSPCMs_rate_dataset = 'BothSPCMs_counts_per_s'
            self.experiment.scan_var_dataset = "scan_variables"
            self.experiment.scan_sequence1_dataset = "scan_sequence1"
            self.experiment.scan_sequence2_dataset = "scan_sequence2"

            """
            Note that the amplitudes below can be used for setting the urukul channels, but are kernel invariants.
            If you are running the laser_stabilizer in your experiment, and you want to set one of the dds channels we
            feedback to (i.e. it is in one of the dds_feedback_lists in ExperimentVariables), then you should use the
            amplitude attribute of the feedback channel. See subroutines/aom_feedback.py for more details.
            """

            ### converts RF power in dBm to amplitudes in V
            self.experiment.ampl_FORT_loading = dB_to_V(self.experiment.p_FORT_loading)
            self.experiment.ampl_cooling_DP_MOT = dB_to_V(self.experiment.p_cooling_DP_MOT)

            ### not in alice
            # self.experiment.ampl_D1_pumping_DP = dB_to_V(self.experiment.p_D1_pumping_DP)
            # self.experiment.ampl_free_ch = dB_to_V(self.experiment.p_free_ch)
            # self.experiment.ampl_excitation = dB_to_V(self.experiment.p_excitation)
            self.experiment.ampl_microwaves = dB_to_V(self.experiment.p_microwaves)
            self.experiment.ampl_AOM_A1 = dB_to_V(self.experiment.p_AOM_A1)
            self.experiment.ampl_AOM_A2 = dB_to_V(self.experiment.p_AOM_A2)
            self.experiment.ampl_AOM_A3 = dB_to_V(self.experiment.p_AOM_A3)
            self.experiment.ampl_AOM_A4 = dB_to_V(self.experiment.p_AOM_A4)
            self.experiment.ampl_AOM_A5 = dB_to_V(self.experiment.p_AOM_A5)
            self.experiment.ampl_AOM_A6 = dB_to_V(self.experiment.p_AOM_A6)

            ### RF powers defined as fractions of the defaults, e.g. the ones we tune during the AOM feedback.
            self.experiment.ampl_FORT_RO = self.experiment.ampl_FORT_loading * self.experiment.p_FORT_RO
            self.experiment.ampl_FORT_PGC = self.experiment.ampl_FORT_loading * self.experiment.p_FORT_PGC
            self.experiment.ampl_FORT_blowaway = self.experiment.ampl_FORT_loading * self.experiment.p_FORT_blowaway
            self.experiment.ampl_FORT_OP = self.experiment.ampl_FORT_loading * self.experiment.p_FORT_OP
            self.experiment.ampl_cooling_DP_RO = self.experiment.ampl_cooling_DP_MOT * self.experiment.p_cooling_DP_RO
            self.experiment.ampl_cooling_DP_PGC = self.experiment.ampl_cooling_DP_MOT * self.experiment.p_cooling_DP_PGC

        elif self.node == "two_nodes":
            ### devices without nicknames. core should come first
            devices_no_alias = ["core",
                                "core_dma",
                                "scheduler",
                                "urukul0_cpld", "urukul1_cpld", "urukul2_cpld",
                                "zotino0",  # for controlling coils
                                "sampler0",  # for measuring laser power PD
                                "sampler1", # for reading in volts in the coil tune experiment
                                "sampler2",
                                *[f"ttl{i}" for i in range(16)]]
            for dev in devices_no_alias:
                self.experiment.setattr_device(dev)

            ### devices can also be nicknamed here:
            self.experiment.ttl_microwave_switch = self.experiment.ttl4
            self.experiment.ttl_repump_switch = self.experiment.ttl5
            self.experiment.ttl_SPCM0 = self.experiment.ttl0
            self.experiment.ttl_pumping_repump_switch = self.experiment.ttl7
            self.experiment.ttl_Luca_trigger = self.experiment.ttl6
            self.experiment.ttl_GRIN2_switch = self.experiment.ttl13

            ### for debugging/logging purposes in experiments
            self.experiment.coil_names = ["AZ bottom","AZ top","AX","AY"]

            self.experiment.AZ_bottom_Zotino_channel = 0
            self.experiment.AZ_top_Zotino_channel = 1
            self.experiment.AX_Zotino_channel = 2
            self.experiment.AY_Zotino_channel = 3

            self.experiment.coil_channels = [self.experiment.AZ_bottom_Zotino_channel,
                                             self.experiment.AZ_top_Zotino_channel,
                                             self.experiment.AX_Zotino_channel,
                                             self.experiment.AY_Zotino_channel]

            self.experiment.UV_trig_channel = [8]
            self.experiment.Osc_trig_channel = [10]

            ### dataset names
            self.experiment.measurements_progress = 'measurements_progress'
            self.experiment.SPCM0_rate_dataset = 'SPCM0_counts_per_s'
            self.experiment.SPCM1_rate_dataset = 'SPCM1_counts_per_s'
            self.experiment.scan_var_dataset = "scan_variables"
            self.experiment.scan_sequence1_dataset = "scan_sequence1"
            self.experiment.scan_sequence2_dataset = "scan_sequence2"

            """
            Note that the amplitudes below can be used for setting the urukul channels, but are kernel invariants.
            If you are running the laser_stabilizer in your experiment, and you want to set one of the dds channels we
            feedback to (i.e. it is in one of the dds_feedback_lists in ExperimentVariables), then you should use the
            amplitude attribute of the feedback channel. See subroutines/aom_feedback.py for more details.
            """

            ### converts RF power in dBm to amplitudes in V
            self.experiment.ampl_FORT_loading = dB_to_V(self.experiment.p_FORT_loading)
            self.experiment.ampl_cooling_DP_MOT = dB_to_V(self.experiment.p_cooling_DP_MOT)
            self.experiment.ampl_MW_RF_dds = dB_to_V(self.experiment.p_MW_RF_dds)
            self.experiment.ampl_excitation = dB_to_V(self.experiment.p_excitation)
            self.experiment.ampl_microwaves = dB_to_V(self.experiment.p_microwaves)
            self.experiment.ampl_AOM_A1 = dB_to_V(self.experiment.p_AOM_A1)
            self.experiment.ampl_AOM_A2 = dB_to_V(self.experiment.p_AOM_A2)
            self.experiment.ampl_AOM_A3 = dB_to_V(self.experiment.p_AOM_A3)
            self.experiment.ampl_AOM_A4 = dB_to_V(self.experiment.p_AOM_A4)
            self.experiment.ampl_AOM_A5 = dB_to_V(self.experiment.p_AOM_A5)
            self.experiment.ampl_AOM_A6 = dB_to_V(self.experiment.p_AOM_A6)

            ### RF powers defined as fractions of the defaults, e.g. the ones we tune during the AOM feedback.
            self.experiment.ampl_FORT_RO = self.experiment.ampl_FORT_loading * self.experiment.p_FORT_RO
            self.experiment.ampl_FORT_PGC = self.experiment.ampl_FORT_loading * self.experiment.p_FORT_PGC
            self.experiment.ampl_FORT_blowaway = self.experiment.ampl_FORT_loading * self.experiment.p_FORT_blowaway
            self.experiment.ampl_FORT_OP = self.experiment.ampl_FORT_loading * self.experiment.p_FORT_OP
            self.experiment.ampl_cooling_DP_RO = self.experiment.ampl_cooling_DP_MOT * self.experiment.p_cooling_DP_RO
            self.experiment.ampl_cooling_DP_PGC = self.experiment.ampl_cooling_DP_MOT * self.experiment.p_cooling_DP_PGC
        else:
            raise KeyError

        ### functions
        @rpc(flags={"async"})
        def print_async(*x):
            """print asynchronously so we don't block the RTIO counter.
            useful for debugging"""
            print(*x)

        self.experiment.print_async = print_async

        def write_results_wrapper(kwargs={}):
            write_results(experiment=self.experiment, **kwargs)

        self.experiment.write_results = write_results_wrapper

        # THIS MUST COME LAST IN BASE.BUILD
        # get a list of all attributes of experiment up to this point. if base.build is called in your experiment
        # before any GUI arguments are defined, then this can be used to grab those later by taking a difference
        self.exp_var_names = dir(self.experiment)
        logging.debug("base build - done")


    def set_datasets_from_gui_args(self):
        """
        This should be called at the end of your experiment's build method to archive the GUI arguments.

        For this to work, it is assumed that the line 'self.exp_var_names = dir(self.experiment)' comes
        last in base.build above.
        :return:
        """
        new_exp_var_names = [x for x in dir(self.experiment) if x not in self.exp_var_names]
        for name in new_exp_var_names:
            try:
                self.experiment.set_dataset(name, getattr(self.experiment, name))
            except Exception as e:
                logging.debug(e)


    def prepare_microwave_RAM(self, MW_ramp_time, MW_pulse_length):
        """
        preparation of smooth microwave pulse with RAM. This generates amplitudes_list representing a smooth pulse
        to be used in experiment_functions to generate smooth MW pulses.
        """
        MW_steps_rise = 30  # number of amplitude points during the rise and fall time
        MW_amp_low, MW_amp_high = 0.0, dB_to_V(self.experiment.p_microwaves)  # low and high amplitudes in scale from 0 to 1

        MW_step_ticks = int(
            (MW_ramp_time / MW_steps_rise) / (
                    4 * ns))  ### Step size

        if MW_pulse_length > 2 * MW_ramp_time:
            MW_dwell_time = MW_pulse_length - 2 * MW_ramp_time
        else:
            MW_dwell_time = 0.0

        MW_steps_dwell = int(
            MW_steps_rise / MW_ramp_time * MW_dwell_time)  # Number of dwell points

        ### Gaussian function.
        MW_x_vals = [0.0 + 3.1 * i / (MW_steps_rise - 1) for i in range(MW_steps_rise)]
        MW_raw = [math.exp(-0.5 * x * x) for x in MW_x_vals]
        MW_g_min, MW_g_max = MW_raw[0], MW_raw[-1]
        MW_norm = [(r - MW_g_min) / (MW_g_max - MW_g_min) for r in MW_raw]

        ### scale into respective ramp according to amplitude.
        MW_amp_points_rise = [MW_amp_low + n * (MW_amp_high - MW_amp_low) for n in MW_norm]
        MW_amp_points_fall = list(
            reversed([MW_amp_low + n * (MW_amp_high - MW_amp_low) for n in MW_norm]))

        ### The full waveform.
        MW_amp_points = (
                MW_amp_points_rise +
                [MW_amp_high] * MW_steps_dwell +
                MW_amp_points_fall
        )

        print(f'microwave RAM MW_amp_points: {len(MW_amp_points)}')  ### Underflow error if larger than ~500

        ### some data conversion needed for RAM
        MW_amplitudes_arr = np.zeros(len(MW_amp_points), dtype=np.int32)
        self.experiment.dds_microwaves.amplitude_to_ram(MW_amp_points, MW_amplitudes_arr)
        MW_amplitudes_list = list(MW_amplitudes_arr)

        ### This is calculation of steps based on above parameters
        MW_total_points = len(MW_amplitudes_list)

        self.experiment.MW_step_size = MW_step_ticks
        self.experiment.MW_total_points = MW_total_points
        self.experiment.MW_amplitudes_list = MW_amplitudes_list

    def prepare_all_microwave_RAM_profiles(self):
        """
        Prepares microwave RAM waveforms for 00, 01, and 11 transitions. Stores the resulting step size, total points,
        and amplitude lists as attributes on self.experiment for use in experiment_functions.
        This gets called in prepare() below.
        """

        def set_MW_profile(suffix, ramp_time, pulse_length):
            self.prepare_microwave_RAM(ramp_time, pulse_length)
            setattr(self.experiment, f"MW_{suffix}_step_size", self.experiment.MW_step_size)
            setattr(self.experiment, f"MW_{suffix}_total_points", self.experiment.MW_total_points)
            setattr(self.experiment, f"MW_{suffix}_amplitudes_list", self.experiment.MW_amplitudes_list)

        set_MW_profile("00", self.experiment.t_MW_00_ramp, self.experiment.t_microwave_00_pulse)
        set_MW_profile("01", self.experiment.t_MW_01_ramp, self.experiment.t_microwave_01_pulse)
        set_MW_profile("11", self.experiment.t_MW_11_ramp, self.experiment.t_microwave_11_pulse)

    def prepare(self):
        """
        Initialize DeviceAliases, compute DDS amplitudes from powers, instantiate the laser servo,
        any other math that needs to happen before we run stuff on the kernel.

        The main difference between Base.build and Base.prepare is that build should contain things we only
        want to happen once per experiment, whereas we might want to call prepare each iteration to reinitialize
        things pertaining to hardware.

        :return:
        """

        ### node independent stuff

        ### set the variables again. because prepare may be called multiple times, e.g. in GeneralVariableScan,
        ### we want to make sure we load up the most recent datasets. this also allows us to change datasets on the fly
        ### from the dashboard while the experiment is running.

        self.experiment.Rigol_modulation_volts = 0.0

        self.experiment.advance = 1

        ### i don't think this is getting the most recent value of the dataset.
        # exclude_keywords = ['history']  # for autogenerated datasets so we don't have to remember to add variables later
        # setattr_variables(self.experiment, exclude_list=[], exclude_keywords=exclude_keywords)


        # ndsp - k10cr1 waveplate rotator datasets
        self.experiment.setpoint_datasets = ["best_852HWP_to_max", "best_852QWP_to_max", "best_852_power",
                                             "best_852_power_ref"]
        self.experiment.default_setpoints = [getattr(self.experiment, dataset) for dataset in
                                             self.experiment.setpoint_datasets]


        ### finding which sampler channel is used for AOM5 and 6, for exmaple, for monitoring MOT RP in experiment_functions.
        config_file = os.path.join(cwd, "repository\\qn_artiq_routines\\utilities\\config\\", self.node,
                                   "feedback_channels.json")
        with open(config_file) as f:
            stabilizer_dict = json.load(f)

        self.experiment.RP_sampler_name = "sampler0"
        self.experiment.RP_AOM5_ch = stabilizer_dict[self.experiment.RP_sampler_name]["dds_AOM_A5"]["sampler_ch"]
        self.experiment.RP_AOM6_ch = stabilizer_dict[self.experiment.RP_sampler_name]["dds_AOM_A6"]["sampler_ch"]

        if self.node == "alice":
            # initialize named channels.
            self.experiment.named_devices = DeviceAliases(
                experiment=self.experiment,
                device_aliases=[
                    'dds_FORT',
                    'dds_D1_pumping_DP',
                    'dds_cooling_DP',
                    'dds_MW_RF',
                    'GRIN1and2_dds',
                    'dds_microwaves',
                    *[f'dds_AOM_A{i + 1}' for i in range(6)]  # the fiber AOMs
                ]
            )

            ### this is an attribute of of the experiment in case we want to access it elsewhere
            self.experiment.all_dds_channels = [getattr(self.experiment, f'urukul{card}_ch{channel}')
                                                for card in range(3) for channel in range(4)]

            ### convert times to machine units
            seconds_to_mu = self.experiment.core.seconds_to_mu
            self.experiment.t_MOT_loading_mu = seconds_to_mu(self.experiment.t_MOT_loading)
            self.experiment.t_FORT_loading_mu = seconds_to_mu(self.experiment.t_FORT_loading)
            self.experiment.t_SPCM_exposure_mu = seconds_to_mu(self.experiment.t_SPCM_exposure)

            ### mainly for cost functions
            try:
                self.experiment.SPCM0_RO1_list = [0] * self.experiment.n_measurements
                self.experiment.SPCM0_RO2_list = [0] * self.experiment.n_measurements
                self.experiment.SPCM1_RO1_list = [0] * self.experiment.n_measurements
                self.experiment.SPCM1_RO2_list = [0] * self.experiment.n_measurements
                self.experiment.BothSPCMs_RO1_list = [0] * self.experiment.n_measurements
                self.experiment.BothSPCMs_RO2_list = [0] * self.experiment.n_measurements
                self.experiment.atom_loading_time_list = [0.0] * self.experiment.n_measurements

            except:
                ### if this fails, your experiment probably didn't need it
                self.experiment.print_async("experiment does not have variable n_measurements")
                # logging.warn("experiment does not have variable n_measurements")

            slow_feedback_dds_list = eval(self.experiment.slow_feedback_dds_list)
            fast_feedback_dds_list = eval(self.experiment.fast_feedback_dds_list)

            ### could implement this but it isn't needed right now
            # self.experiment.slow_laser_stabilizer = AOMPowerStabilizer(experiment=self.experiment,
            #                                                       dds_names=slow_feedback_dds_list,
            #                                                       iterations=self.experiment.aom_feedback_iterations,
            #                                                       averages=self.experiment.aom_feedback_averages,
            #                                                       leave_AOMs_on=True)

            ### feedback channels which are fast enough to include on every atom loading attempt.
            ### this excludes things which use fW detectors which have slow rise time.
            self.experiment.laser_stabilizer = AOMPowerStabilizer(experiment=self.experiment,
                                                                  dds_names=fast_feedback_dds_list,
                                                                  iterations=self.experiment.aom_feedback_iterations,
                                                                  averages=self.experiment.aom_feedback_averages,
                                                                  leave_AOMs_on=False,
                                                                  leave_MOT_AOMs_on=True)

            ### todo: make OP feedback list in ExperimentVariables, so we can feedback to this separately.
            ###  this allows us to feedback to D1, pumping repump, etc every iteration instead of every measurement.
            # self.experiment.OP_laser_stabilizer = AOMPowerStabilizer(experiment=self.experiment,
            #                                                       dds_names=OP_feedback_dds_list,
            #                                                       iterations=self.experiment.aom_feedback_iterations,
            #                                                       averages=self.experiment.aom_feedback_averages,
            #                                                       leave_AOMs_on=False,
            #                                                       leave_MOT_AOMs_on=True)

            self.experiment.set_dataset("feedbackchannels",
                             [ch.dB_dataset for ch in self.experiment.laser_stabilizer.all_channels],
                             broadcast=True, persist=True)

            self.experiment.initial_RF_dB_values = np.zeros(len(fast_feedback_dds_list))
            for ch_i, ch in enumerate(self.experiment.laser_stabilizer.all_channels):
                self.experiment.initial_RF_dB_values[ch_i] = self.experiment.get_dataset(ch.dB_dataset, archive=False)
                try:
                    # self.experiment.get_dataset(self.experiment.laser_stabilizer.all_channels[ch_i].dB_history_dataset,
                    #                             archive=False)
                    self.experiment.append_to_dataset(
                        self.experiment.laser_stabilizer.all_channels[ch_i].dB_history_dataset,
                        float(self.experiment.initial_RF_dB_values[ch_i]))

                except KeyError:
                    self.experiment.set_dataset(self.experiment.laser_stabilizer.all_channels[ch_i].dB_history_dataset,
                                     [float(self.experiment.initial_RF_dB_values[ch_i])], broadcast=True)

            self.prepare_all_microwave_RAM_profiles()

        elif self.node == "bob":
            # self.experiment.FORT_pol_stabilizer = FORTPolarizationStabilizer(experiment=self.experiment,
            #                                                                  initialize_to_home = False,
            #                                                                  search_start_from_scratch = False,
            #                                                                  reduce_sample_pts = False)

            # initialize named channels.
            self.experiment.named_devices = DeviceAliases(
                experiment=self.experiment,
                device_aliases=[
                    'dds_FORT',
                    'dds_cooling_DP',
                    'dds_MW_RF',
                    # 'dds_GRIN1',
                    # 'dds_GRIN2',
                    'dds_microwaves',
                    'dds_D1_pumping_DP',
                    'GRIN1and2_dds',

                    *[f'dds_AOM_A{i + 1}' for i in range(6)]  # the fiber AOMs
                ]
            )

            ### this is an attribute of of the experiment in case we want to access it elsewhere
            self.experiment.all_dds_channels = [getattr(self.experiment, f'urukul{card}_ch{channel}')
                                                for card in range(3) for channel in range(4)]

            ### convert times to machine units
            seconds_to_mu = self.experiment.core.seconds_to_mu
            self.experiment.t_MOT_loading_mu = seconds_to_mu(self.experiment.t_MOT_loading)
            self.experiment.t_FORT_loading_mu = seconds_to_mu(self.experiment.t_FORT_loading)
            self.experiment.t_SPCM_exposure_mu = seconds_to_mu(self.experiment.t_SPCM_exposure)

            ### mainly for cost functions
            try:
                self.experiment.SPCM0_RO1_list = [0] * self.experiment.n_measurements
                self.experiment.SPCM0_RO2_list = [0] * self.experiment.n_measurements
                self.experiment.SPCM1_RO1_list = [0] * self.experiment.n_measurements
                self.experiment.SPCM1_RO2_list = [0] * self.experiment.n_measurements
                self.experiment.BothSPCMs_RO1_list = [0] * self.experiment.n_measurements
                self.experiment.BothSPCMs_RO2_list = [0] * self.experiment.n_measurements
                self.experiment.atom_loading_time_list = [0.0] * self.experiment.n_measurements

            except:
                ### if this fails, your experiment probably didn't need it
                self.experiment.print_async("experiment does not have variable n_measurements")
                # logging.warn("experiment does not have variable n_measurements")

            slow_feedback_dds_list = eval(self.experiment.slow_feedback_dds_list)
            fast_feedback_dds_list = eval(self.experiment.fast_feedback_dds_list)

            ### could implement this but it isn't needed right now
            # self.experiment.slow_laser_stabilizer = AOMPowerStabilizer(experiment=self.experiment,
            #                                                       dds_names=slow_feedback_dds_list,
            #                                                       iterations=self.experiment.aom_feedback_iterations,
            #                                                       averages=self.experiment.aom_feedback_averages,
            #                                                       leave_AOMs_on=True)

            ### feedback channels which are fast enough to include on every atom loading attempt.
            ### this excludes things which use fW detectors which have slow rise time.
            self.experiment.laser_stabilizer = AOMPowerStabilizer(experiment=self.experiment,
                                                                  dds_names=fast_feedback_dds_list,
                                                                  iterations=self.experiment.aom_feedback_iterations,
                                                                  averages=self.experiment.aom_feedback_averages,
                                                                  leave_AOMs_on=False,
                                                                  leave_MOT_AOMs_on=True)

            self.experiment.set_dataset("feedbackchannels",
                                        [ch.dB_dataset for ch in self.experiment.laser_stabilizer.all_channels],
                                        broadcast=True, persist=True)

            self.experiment.initial_RF_dB_values = np.zeros(len(fast_feedback_dds_list))
            for ch_i, ch in enumerate(self.experiment.laser_stabilizer.all_channels):
                self.experiment.initial_RF_dB_values[ch_i] = self.experiment.get_dataset(ch.dB_dataset, archive=False)
                try:
                    # self.experiment.get_dataset(self.experiment.laser_stabilizer.all_channels[ch_i].dB_history_dataset,
                    #                             archive=False)
                    self.experiment.append_to_dataset(
                        self.experiment.laser_stabilizer.all_channels[ch_i].dB_history_dataset,
                        float(self.experiment.initial_RF_dB_values[ch_i]))

                except KeyError:
                    self.experiment.set_dataset(self.experiment.laser_stabilizer.all_channels[ch_i].dB_history_dataset,
                                                [float(self.experiment.initial_RF_dB_values[ch_i])], broadcast=True)

            self.prepare_all_microwave_RAM_profiles()

        elif self.node == "two_nodes":
            ### initialize named channels.
            self.experiment.named_devices = DeviceAliases(
                experiment=self.experiment,
                device_aliases=[
                    'dds_FORT',
                    'dds_D1_pumping_DP',
                    'dds_cooling_DP',
                    'dds_MW_RF',
                    'GRIN1and2_dds',
                    'dds_microwaves',
                    *[f'dds_AOM_A{i + 1}' for i in range(6)]  # the fiber AOMs
                ]
            )

            ### this is an attribute of of the experiment in case we want to access it elsewhere
            self.experiment.all_dds_channels = [getattr(self.experiment, f'urukul{card}_ch{channel}')
                                                for card in range(3) for channel in range(4)]

            ### convert times to machine units
            seconds_to_mu = self.experiment.core.seconds_to_mu
            self.experiment.t_MOT_loading_mu = seconds_to_mu(self.experiment.t_MOT_loading)
            self.experiment.t_FORT_loading_mu = seconds_to_mu(self.experiment.t_FORT_loading)
            self.experiment.t_SPCM_exposure_mu = seconds_to_mu(self.experiment.t_SPCM_exposure)

            ### mainly for cost functions
            try:
                self.experiment.SPCM0_RO1_list = [0] * self.experiment.n_measurements
                self.experiment.SPCM0_RO2_list = [0] * self.experiment.n_measurements
                self.experiment.SPCM1_RO1_list = [0] * self.experiment.n_measurements
                self.experiment.SPCM1_RO2_list = [0] * self.experiment.n_measurements
                self.experiment.BothSPCMs_RO1_list = [0] * self.experiment.n_measurements
                self.experiment.BothSPCMs_RO2_list = [0] * self.experiment.n_measurements
                self.experiment.atom_loading_time_list = [0.0] * self.experiment.n_measurements

            except:
                ### if this fails, your experiment probably didn't need it
                self.experiment.print_async("experiment does not have variable n_measurements")
                # logging.warn("experiment does not have variable n_measurements")

            slow_feedback_dds_list = eval(self.experiment.slow_feedback_dds_list)
            fast_feedback_dds_list = eval(self.experiment.fast_feedback_dds_list)

            ### could implement this but it isn't needed right now
            # self.experiment.slow_laser_stabilizer = AOMPowerStabilizer(experiment=self.experiment,
            #                                                       dds_names=slow_feedback_dds_list,
            #                                                       iterations=self.experiment.aom_feedback_iterations,
            #                                                       averages=self.experiment.aom_feedback_averages,
            #                                                       leave_AOMs_on=True)

            ### feedback channels which are fast enough to include on every atom loading attempt.
            ### this excludes things which use fW detectors which have slow rise time.
            self.experiment.laser_stabilizer = AOMPowerStabilizer(experiment=self.experiment,
                                                                  dds_names=fast_feedback_dds_list,
                                                                  iterations=self.experiment.aom_feedback_iterations,
                                                                  averages=self.experiment.aom_feedback_averages,
                                                                  leave_AOMs_on=False,
                                                                  leave_MOT_AOMs_on=True)

            self.experiment.set_dataset("feedbackchannels",
                                        [ch.dB_dataset for ch in self.experiment.laser_stabilizer.all_channels],
                                        broadcast=True, persist=True)

            self.experiment.initial_RF_dB_values = np.zeros(len(fast_feedback_dds_list))
            for ch_i, ch in enumerate(self.experiment.laser_stabilizer.all_channels):
                self.experiment.initial_RF_dB_values[ch_i] = self.experiment.get_dataset(ch.dB_dataset, archive=False)
                try:
                    # self.experiment.get_dataset(self.experiment.laser_stabilizer.all_channels[ch_i].dB_history_dataset,
                    #                             archive=False)
                    self.experiment.append_to_dataset(
                        self.experiment.laser_stabilizer.all_channels[ch_i].dB_history_dataset,
                        float(self.experiment.initial_RF_dB_values[ch_i]))

                except KeyError:
                    self.experiment.set_dataset(self.experiment.laser_stabilizer.all_channels[ch_i].dB_history_dataset,
                                                [float(self.experiment.initial_RF_dB_values[ch_i])], broadcast=True)

            self.prepare_all_microwave_RAM_profiles()

        else:
            raise KeyError

        logging.debug("base prepare - done")

    def initialize_datasets(self):
        """
        Initialize datasets which are common to many experiments
        :return:
        """
        self.experiment.set_dataset("iteration", 0, broadcast=True)
        self.experiment.set_dataset("n_measurements", self.experiment.n_measurements, broadcast=True)
        self.experiment.set_dataset("SPCM0_RO1", [0], broadcast=True)
        self.experiment.set_dataset("SPCM0_RO2", [0], broadcast=True)
        self.experiment.set_dataset("SPCM1_RO1", [0], broadcast=True)
        self.experiment.set_dataset("SPCM1_RO2", [0], broadcast=True)
        self.experiment.set_dataset("BothSPCMs_RO1", [0], broadcast=True)
        self.experiment.set_dataset("BothSPCMs_RO2", [0], broadcast=True)
        self.experiment.set_dataset("BothSPCMs_parity_RO", [0], broadcast=True)
        self.experiment.set_dataset("SPCM0_test_RO", [0], broadcast=True)
        self.experiment.set_dataset("photocount_bins", [50], broadcast=True)
        self.experiment.set_dataset("SPCM0_FORT_science", [0.0], broadcast=True)
        self.experiment.set_dataset("FORT_MM_science_volts", [0.0], broadcast=True)
        self.experiment.set_dataset("SPCM0_SinglePhoton", [0], broadcast=True)
        self.experiment.set_dataset("reference_tStamps_t1", [0.0], broadcast=True)
        self.experiment.set_dataset("SPCM0_SinglePhoton_tStamps", [[0.0,0.0]], broadcast=True)
        self.experiment.set_dataset("SPCM1_SinglePhoton_tStamps", [[0.0,0.0]], broadcast=True)
        self.experiment.set_dataset("SPCM1_SinglePhoton", [0], broadcast=True)
        self.experiment.set_dataset("SPCM0_every_exc_RO", [0], broadcast=True)
        self.experiment.set_dataset("BothSPCMs_RO_atom_check", [0], broadcast=True)
        self.experiment.set_dataset("n_excitation_cycles", [0], broadcast=True)
        self.experiment.set_dataset("Atom_loading_time", [0.0], broadcast=True)
        self.experiment.set_dataset("time_without_atom", [0.0], broadcast=True)

        self.experiment.set_dataset("BothSPCMs_atom_check_in_loading", [0], broadcast=True)

        self.experiment.set_dataset("SPCM0_total_click_counter", [0], broadcast=True)
        self.experiment.set_dataset("SPCM1_total_click_counter", [0], broadcast=True)

        self.experiment.set_dataset("GRIN1_D1_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("GRIN1_EXC_monitor", [0.0], broadcast=True)

        self.experiment.set_dataset("REPUMP1_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("REPUMP2_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("REPUMP3_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("REPUMP4_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("REPUMP5_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("REPUMP6_monitor", [0.0], broadcast=True)

        self.experiment.set_dataset("PUMPING_REPUMP1_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("PUMPING_REPUMP2_monitor", [0.0], broadcast=True)

        self.experiment.set_dataset("MOT1_end_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("MOT2_end_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("MOT3_end_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("MOT4_end_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("MOT5_end_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("MOT6_end_monitor", [0.0], broadcast=True)

        self.experiment.set_dataset("zotino_test1_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("zotino_test2_monitor", [0.0], broadcast=True)
        self.experiment.set_dataset("Sampler0_test", [0.0], broadcast=True)

        self.experiment.set_dataset("Magnetometer_MOT_X", [0.0], broadcast=True)
        self.experiment.set_dataset("Magnetometer_MOT_Y", [0.0], broadcast=True)
        self.experiment.set_dataset("Magnetometer_MOT_Z", [0.0], broadcast=True)
        self.experiment.set_dataset("Magnetometer_OP_X", [0.0], broadcast=True)
        self.experiment.set_dataset("Magnetometer_OP_Y", [0.0], broadcast=True)
        self.experiment.set_dataset("Magnetometer_OP_Z", [0.0], broadcast=True)
        self.experiment.set_dataset("Magnetometer_Zero_X", [0.0], broadcast=True)
        self.experiment.set_dataset("Magnetometer_Zero_Y", [0.0], broadcast=True)
        self.experiment.set_dataset("Magnetometer_Zero_Z", [0.0], broadcast=True)
        self.experiment.set_dataset("n_feedback_per_iteration", [0.0], broadcast=True) ### number of times the AOM feedback runs in each iteration
        self.experiment.set_dataset("n_atom_loaded_per_iteration", [0.0], broadcast=True) ### number of times the AOM feedback runs in each iteration

        self.experiment.set_dataset("coil_driver_AZ_bottom_MOT", [0.0], broadcast=True)
        self.experiment.set_dataset("coil_driver_AZ_top_MOT", [0.0], broadcast=True)
        self.experiment.set_dataset("coil_driver_AX_MOT", [0.0], broadcast=True)
        self.experiment.set_dataset("coil_driver_AY_MOT", [0.0], broadcast=True)

        self.experiment.set_dataset("atom_loading_wall_clock", [0.0], broadcast=True)

        self.experiment.set_dataset("FORT_MM_monitor", [], broadcast=True)
        self.experiment.set_dataset("FORT_APD_monitor", [], broadcast=True)

        self.experiment.set_dataset("angle_780_HWP", [], broadcast=True)
        self.experiment.set_dataset("angle_780_QWP", [], broadcast=True)


    @kernel
    def initialize_hardware(self, turn_off_dds_channels=True, turn_off_zotinos=True):
        """
        hardware initialization and setting of ttl switches, and set datasets

        'turn_off_dds_channels': will turn off all Urukul channel outputs if True (default).
        'turn_off_zotinos': will set all Zotino channels to 0*V if True (default).
        :return:
        """

        if self.node == "alice":
            self.experiment.core.reset()

            self.experiment.set_dataset(self.experiment.measurements_progress,0.0,broadcast=True)
            self.experiment.set_dataset(self.experiment.scan_var_dataset,'',broadcast=True)
            self.experiment.set_dataset(self.experiment.scan_sequence1_dataset,[0.0],broadcast=True)
            self.experiment.set_dataset(self.experiment.scan_sequence2_dataset,[0.0],broadcast=True)

            self.experiment.named_devices.initialize()

            ### TTL Setting: individually set each TTL port to input or output
            ### ttl0~3
            self.experiment.ttl_SPCM0.input()
            self.experiment.ttl_SPCM1.input()

            ### ttl4~7: already configured to be used as output at TTL card
            self.experiment.ttl_microwave_switch.output()
            self.experiment.ttl_repump_switch.output()
            self.experiment.ttl_exc0_switch.output()
            # self.experiment.ttl_scope_trigger.output()
            self.experiment.ttl_pumping_repump_switch.output()

            ### ttl8~11
            self.experiment.ttl_D1_lock_monitor.input()

            ### ttl12~15: already configured to be used as output at TTL card
            self.experiment.ttl_GRIN2_switch.output()
            self.experiment.ttl_GRIN1_switch.output()
            self.experiment.ttl_GRIN2_switch.on()  ### ensure no excitation or D1 is on at the beginning
            self.experiment.ttl_GRIN1_switch.on()  ### ensure no excitation or D1 is on at the beginning

            self.experiment.ttl_SPCM0_logic.output()
            self.experiment.ttl_SPCM1_logic.output()
            delay(100*us)
            self.experiment.ttl_SPCM0_logic.on()
            self.experiment.ttl_SPCM1_logic.on()

            self.experiment.FORT_mod_switch.output()

            delay(1 * ms)

            self.experiment.sampler0.init() # for reading laser feedback
            self.experiment.sampler1.init() # for reading laser feedback
            self.experiment.sampler2.init() # for reading laser feedback

            for i in range(8):
                self.experiment.sampler0.set_gain_mu(i, 8)
                delay(100 * us)

            for i in range(8):
                if i == 6:
                    self.experiment.sampler1.set_gain_mu(i, 0) ### gain for the FORT APD channel
                    delay(100 * us)
                else:
                    self.experiment.sampler1.set_gain_mu(i, 0)
                    delay(100 * us)

            ### turn on/off any switches. this ensures that switches always start in a default state,
            ### which might not happen if we abort an experiment in the middle and don't reset it
            self.experiment.ttl_exc0_switch.on()   # blocks excitation
            delay(1*ms)
            self.experiment.ttl_repump_switch.on() # block RF to get to the RP AOM
            delay(1*ms)
            self.experiment.ttl_pumping_repump_switch.on() # block RF to get to the PR AOM
            delay(1*ms)
            self.experiment.ttl_microwave_switch.on() # blocks the microwaves after the mixer
            delay(1*ms)
            self.experiment.FORT_mod_switch.off()  # off = no modulation


            if turn_off_zotinos:
                self.experiment.zotino0.init()
                for zot_ch in range(32):
                    self.experiment.zotino0.write_dac(zot_ch, 0.0)
                    self.experiment.zotino0.load()
                    delay(1 * ms)

            if turn_off_dds_channels:
                for dds_ch in self.experiment.all_dds_channels:
                    dds_ch.sw.off()
                    delay(1*ms)

            self.experiment.zotino0.write_dac(5, 0.62)  # turn on the VCA for the FORT
            self.experiment.zotino0.load()
            delay(1 * ms)

            self.experiment.core.break_realtime()

        elif self.node == "bob":
            self.experiment.core.reset()

            self.experiment.set_dataset(self.experiment.measurements_progress,0.0,broadcast=True)
            self.experiment.set_dataset(self.experiment.scan_var_dataset,'',broadcast=True)
            self.experiment.set_dataset(self.experiment.scan_sequence1_dataset,[0.0],broadcast=True)
            self.experiment.set_dataset(self.experiment.scan_sequence2_dataset,[0.0],broadcast=True)

            self.experiment.named_devices.initialize()


            ### TTL Setting: individually set each TTL port to input or output
            ### ttl0~3
            self.experiment.ttl_SPCM0.input()
            self.experiment.ttl_SPCM1.input()

            ### ttl4~7: already configured to be used as output at TTL card
            self.experiment.ttl_microwave_switch.output()
            self.experiment.ttl_repump_switch.output()
            self.experiment.ttl_exc0_switch.output()
            # self.experiment.ttl_scope_trigger.output()
            self.experiment.ttl_pumping_repump_switch.output()

            ### ttl8~11
            self.experiment.ttl_D1_lock_monitor.input()
            self.experiment.FORT_mod_switch.output()

            ### ttl12~15: already configured to be used as output at TTL card
            self.experiment.ttl_D1_pumping.output()
            self.experiment.ttl_GRIN2_switch.output()
            self.experiment.ttl_GRIN1_switch.output()

            self.experiment.sampler0.init() # for reading laser feedback
            self.experiment.sampler1.init() # for reading laser feedback
            self.experiment.sampler2.init() # for reading laser feedback

            ### turn on/off any switches. this ensures that switches always start in a default state,
            ### which might not happen if we abort an experiment in the middle and don't reset it
            self.experiment.ttl_microwave_switch.on() # blocks the microwaves after the mixer
            # delay(1*ms)
            self.experiment.ttl_repump_switch.on() # blocks RF to get to the RP AOM
            delay(1*ms)
            self.experiment.ttl_D1_pumping.on()   ### ensure no D1 is on at the beginning
            delay(1 * ms)
            self.experiment.ttl_GRIN2_switch.on() ### ensure no excitation or D1 is on at the beginning
            delay(1 * ms)
            self.experiment.ttl_GRIN1_switch.on() ### ensure no excitation or D1 is on at the beginning
            delay(1*ms)
            self.experiment.ttl_pumping_repump_switch.on() # block RF to get to the PR AOM
            delay(1*ms)
            self.experiment.ttl_exc0_switch.on()
            delay(1 * ms)

            if turn_off_zotinos:
                self.experiment.zotino0.init()
                for zot_ch in range(32):
                    self.experiment.zotino0.write_dac(zot_ch, 0.0)
                    self.experiment.zotino0.load()
                    delay(1 * ms)

            if turn_off_dds_channels:
                for dds_ch in self.experiment.all_dds_channels:
                    dds_ch.sw.off()
                    delay(1 * ms)

            self.experiment.core.break_realtime()


        elif self.node == "two_nodes":
            self.experiment.core.reset()

            self.experiment.set_dataset(self.experiment.measurements_progress,0.0,broadcast=True)
            self.experiment.set_dataset(self.experiment.scan_var_dataset,'',broadcast=True)
            self.experiment.set_dataset(self.experiment.scan_sequence1_dataset,[0.0],broadcast=True)
            self.experiment.set_dataset(self.experiment.scan_sequence2_dataset,[0.0],broadcast=True)

            self.experiment.named_devices.initialize()

            self.experiment.ttl_microwave_switch.output()
            self.experiment.ttl_repump_switch.output()
            self.experiment.ttl6.output()  # for outputting a trigger
            self.experiment.ttl1.input()

            ### for diagnostics including checking the performance of fast switches for SPCM gating
            self.experiment.ttl9.output()
            delay(1 * ms)
            self.experiment.ttl9.off()

            self.experiment.sampler0.init() # for reading laser feedback
            self.experiment.sampler1.init() # for reading laser feedback
            self.experiment.sampler2.init() # for reading laser feedback

            ### turn on/off any switches. this ensures that switches always start in a default state,
            ### which might not happen if we abort an experiment in the middle and don't reset it
            self.experiment.ttl_repump_switch.off() # allow RF to get to the RP AOM
            delay(1*ms)
            self.experiment.ttl_pumping_repump_switch.on() # block RF to get to the PR AOM
            delay(1*ms)
            self.experiment.ttl_microwave_switch.on() # blocks the microwaves after the mixer
            delay(1*ms)

            if turn_off_zotinos:
                self.experiment.zotino0.init()
                for zot_ch in range(32):
                    self.experiment.zotino0.write_dac(zot_ch, 0.0)
                    self.experiment.zotino0.load()
                    delay(1 * ms)

            if turn_off_dds_channels:
                for dds_ch in self.experiment.all_dds_channels:
                    dds_ch.sw.off()
                    delay(1 * ms)

            self.experiment.core.break_realtime()
        
        self.experiment.print_async("initialize hardware - done")


### do this so the code above will not actually run when ARTIQ scans the repository
if __name__ == '__main__':
    pass


